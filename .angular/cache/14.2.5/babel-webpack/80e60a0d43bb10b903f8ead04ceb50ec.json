{"ast":null,"code":"import { isUserTimingAPISupported } from './is-user-timing-api-supported';\nimport { isPerformanceObservableSupported } from './is-performance-observable-supported';\nimport { isNodeJSEnv } from './is-nodejs-env'; // Map() is not used in order to decrease the bundle\n\nlet marksMap = {};\nlet marksObserver = {};\n/**\n * Get the current time based on User Timing API or Date\n *\n * @returns number\n *\n */\n\nconst getTimeNow = () => isUserTimingAPISupported ? performance.now() : Date.now();\n/**\n * Clear marks and measure of performance event\n *\n * @param markName - Performance marker to be checked\n *\n * @returns void\n *\n */\n\n\nconst clear = markName => {\n  marksMap[markName] = undefined; // Removes PerformanceObserver references from memory\n\n  if (!!marksObserver[markName]) {\n    marksObserver[markName] = undefined;\n  }\n\n  if (!isUserTimingAPISupported) {\n    return;\n  } // Some versions of NodeJS doesn't support this method\n\n\n  if (!isNodeJSEnv) {\n    performance.clearMeasures(markName);\n  }\n\n  performance.clearMarks(markName);\n};\n/**\n * Start performance measure of event\n *\n * @param markName - Performance marker to be started\n *\n * @returns number\n *\n */\n\n\nconst start = markName => {\n  if (isUserTimingAPISupported) {\n    if (isNodeJSEnv && isPerformanceObservableSupported) {\n      // eslint-disable-next-line compat/compat\n      const obs = new PerformanceObserver(list => {\n        marksObserver[markName] = list.getEntries().find(f => f.name === markName);\n        obs.disconnect();\n      });\n      obs.observe({\n        entryTypes: ['measure']\n      });\n    }\n\n    performance.mark(markName);\n  }\n\n  marksMap[markName] = getTimeNow();\n};\n/**\n * Finishes performance measure of event and\n * clear marks and measure if applicable\n *\n * @param markName - Performance marker to be checked\n * @param markNameToCompare - Optional mark to compare to\n *\n * @returns PerfMarksPerformanceEntry\n *\n */\n\n\nconst end = (markName, markNameToCompare) => {\n  try {\n    const startTime = marksMap[markName];\n\n    if (!isUserTimingAPISupported) {\n      return startTime ? {\n        duration: getTimeNow() - startTime,\n        startTime,\n        entryType: 'measure',\n        name: markName\n      } : {};\n    } // If there's no User Timing mark to be compared with,\n    // the package will create one to be used for better comparison\n\n\n    if (!markNameToCompare) {\n      performance.mark(`${markName}-end`);\n    }\n\n    performance.measure(markName, markName, markNameToCompare || `${markName}-end`);\n\n    if (isNodeJSEnv) {\n      if (!!marksObserver[markName]) {\n        return marksObserver[markName];\n      }\n\n      return startTime ? {\n        duration: getTimeNow() - startTime,\n        startTime,\n        entryType: 'measure',\n        name: markName\n      } : {};\n    }\n\n    const entry = performance.getEntriesByName(markName).pop();\n    return entry || {};\n  } catch (e) {\n    // If previous mark was missing for some reason, this will throw.\n    // This could only happen if something in event loop crashed\n    // in an unexpected place earlier.\n    // Don't pile on with more errors.\n    return {};\n  } finally {\n    // Clear marks immediately to avoid growing buffer.\n    clear(markName); // Clear marks used for comparison in case of it's value was passed\n    // If the mark to compare is not passed, it should remove the one we create with `-end` suffix\n\n    clear(markNameToCompare || `${markName}-end`);\n  }\n};\n/**\n * Clear all marks and measures of performance event\n *\n * @returns void\n *\n */\n\n\nconst clearAll = () => {\n  marksMap = {};\n  marksObserver = {};\n\n  if (!isUserTimingAPISupported) {\n    return;\n  } // Some versions of NodeJS doesn't support this method\n\n\n  if (!isNodeJSEnv) {\n    performance.clearMeasures();\n  }\n\n  performance.clearMarks();\n};\n\nexport { start, end, clear, clearAll, isUserTimingAPISupported, isPerformanceObservableSupported };","map":null,"metadata":{},"sourceType":"module"}